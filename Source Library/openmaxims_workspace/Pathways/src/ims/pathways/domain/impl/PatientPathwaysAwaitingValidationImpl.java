//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Mara Iroaie using IMS Development Environment (version 1.80 build 5256.13787)
// Copyright (C) 1995-2014 IMS MAXIMS. All rights reserved.

package ims.pathways.domain.impl;

import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.vo.CATSReferralFilterVo;
import ims.RefMan.vo.CatsReferralListManualAssemblyVo;
import ims.RefMan.vo.CatsReferralListManualAssemblyVoCollection;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.domain.CatsReferralListVoAssembler;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.clinical.domain.objects.Service;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.ServiceShortVo;
import ims.core.vo.ServiceShortVoCollection;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.ServiceShortVoAssembler;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.pathways.domain.base.impl.BasePatientPathwaysAwaitingValidationWorklistImpl;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.vo.PatientPathwayJourneyRefVo;
import ims.pathways.vo.PatientPathwaysAwaitingValidationSearchCriteriaVo;
import ims.pathways.vo.PatientPathwaysAwaitingValidationWorklistVo;
import ims.pathways.vo.PatientPathwaysAwaitingValidationWorklistVoCollection;
import ims.pathways.vo.domain.PatientPathwaysAwaitingValidationWorklistVoAssembler;

import java.util.ArrayList;
import java.util.List;
//import ims.RefMan.helper.CatsReferralManualClass;

public class PatientPathwaysAwaitingValidationImpl extends BasePatientPathwaysAwaitingValidationWorklistImpl
{

	private static final long serialVersionUID = 1L;

	public PatientPathwaysAwaitingValidationWorklistVoCollection getPathways(PatientPathwaysAwaitingValidationSearchCriteriaVo searchCriteria)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		String andStr = " and ";
		
		Boolean validationDateAdded = false;
		Boolean rttValidationAdded = false;
		
		 
		
		//WDEV-21431 (Following code commented out and replaced below)
//		StringBuffer hql = new StringBuffer(" select pathways from PatientPathwayJourney as pathways left join pathways.currentClock as cc ");
//		StringBuffer hqlConditions = new StringBuffer(" cc is not null and cc.stopDate is null and (pathways.isRIE is null or pathways.isRIE = 0) ");
//		
//		//WDEV-21431
//		
//		if (searchCriteria != null && searchCriteria.getStartDateIsNotNull() && Boolean.FALSE.equals(searchCriteria.getRttIncluded()))
//		{
//			hqlConditions.append("and pathways.nextValidationDate is not null");
//			validationDateAdded = true;
//			
//			hqlConditions.append(andStr);
//			
//			hqlConditions.append(" pathways.nextValidationDate >= :fromDate ");
//			markers.add("fromDate");
//			DateTime fromDateTime = new DateTime( searchCriteria.getStartDate(), new Time(0, 0));
//			values.add(fromDateTime.getJavaDate());
//			
//			andStr = " and ";
//		}
//		
//		if (searchCriteria != null && searchCriteria.getEndDateIsNotNull() && Boolean.FALSE.equals(searchCriteria.getRttIncluded()))
//		{
//			if (Boolean.FALSE.equals(validationDateAdded))
//			{
//				hqlConditions.append("and pathways.nextValidationDate is not null");
//				validationDateAdded = true;
//			}
//			
//			hqlConditions.append(andStr);
//			
//			hqlConditions.append(" pathways.nextValidationDate <= :toDate ");
//			markers.add("toDate");
//			DateTime toDateTime = new DateTime( searchCriteria.getEndDate(), new Time(0, 0));
//			values.add(toDateTime.getJavaDate());
//			values.add(searchCriteria.getEndDate());
//			andStr = " and ";
//		}
//		
//		//WDEV-21155
//		hqlConditions.append("and pathways.validationCompletedDT is null and pathways.validationCompletedBy is null ");
//		
//		if (searchCriteria != null &&  Boolean.TRUE.equals(searchCriteria.getRttIncluded()))
//		{
//			hqlConditions.append(andStr);
//			
//			hql.append(" left join pathways.currentClock as cc left join cc.currentRTTStatus as crtts ");
//			hqlConditions.append(" (pathways.nextValidationDate >= :notValidatedStartDate and pathways.nextValidationDate <= :notValidatedEndDate)  
//		or (pathways.nextValidationDate is null and  crtts.statusDateTime is not null and  crtts.statusDateTime >= :startDate and crtts.statusDateTime <= :endDate) ");
//			
//			markers.add("notValidatedStartDate");
//			DateTime notValidatedStartDate = new DateTime();
//			values.add(notValidatedStartDate.addDays(-(searchCriteria.getNotValidatedNoOfWeeks() * 7)).getJavaDate());
//			
//			markers.add("notValidatedEndDate");
//			values.add(new DateTime().getJavaDate());
//			
//			markers.add("startDate");
//			DateTime startDate = new DateTime();
//			values.add(startDate.addDays(-(searchCriteria.getNoOfWeeks() * 7)).getJavaDate());
//			
//			markers.add("endDate");
//			values.add(new DateTime().getJavaDate());
//	
//			andStr = " and ";
//			rttValidationAdded = true;
//		}
//		
//		if (hqlConditions != null && hqlConditions.length() > 0)
//		{
//			hqlConditions.insert(0, " where ");
//		}
//		
//		if (Boolean.TRUE.equals(validationDateAdded))
//		{
//			hqlConditions.append(" order by pathways.nextValidationDate desc");	
//		}
//		else if (Boolean.TRUE.equals(rttValidationAdded))
//		{
//			hqlConditions.append(" order by crtts.statusDateTime desc");	
//		}
//
//		List<?> list = getDomainFactory().find(hql.append(hqlConditions.toString()).toString(), markers, values);
//		
//		return PatientPathwaysAwaitingValidationWorklistVoAssembler.createPatientPathwaysAwaitingValidationWorklistVoCollectionFromPatientPathwayJourney(list);

		
		//WDEV-21431 Code below replaces commented out code above
		// Note that HQL query has been vastly changed to accommodate new requirement to list referral service for selected pathways
		
		String serviceIds = "";
		if (searchCriteria != null)
		{
			if (searchCriteria.getService() != null
					&& searchCriteria.getService().getID_Service() != null)
			{
				serviceIds = " and refdetails.service.id in (" + searchCriteria.getService().getID_Service().toString();
			}

			if (searchCriteria.getServices() != null
					&& searchCriteria.getServices().size() > 0)
			{
				for (ServiceShortVo service : searchCriteria.getServices())
				{
					if (service.getID_ServiceIsNotNull())
					{
						if (serviceIds == "")
						{
							serviceIds = " and refdetails.service.id in (" + service.getID_Service().toString();
						}
						else
						{
							serviceIds = serviceIds + "," + service.getID_Service().toString();						
						}	
					}
				}
			}

			if (serviceIds.length() > 0)
			{
				serviceIds = serviceIds + ")";
			}
		}
		//WDEV-2258
		StringBuffer hql = new StringBuffer("select pathways, service, cons "+
											" from CatsReferral as referral "+
											" left join referral.referralDetails as refdetails "+
											" left join refdetails.service as service "+
											" left join refdetails.consultant as cons "+
											" left join referral.journey as pathways "+
											" left join pathways.currentClock as cc ");

		/* TOD MSSQL case - StringBuffer hqlConditions = new StringBuffer("where pathways.validationCompletedDT is null "+
				" and pathways.validationCompletedBy is null "+
				" and (pathways.isRIE = 0 or pathways.isRIE is null) "+
				" and referral.rTTClockImpact = 1" +
				" and (service.isRIE = 0 or service.isRIE is null) " +
				" and refdetails.service.id is not null "+
				" and cc is not null "+
				" and cc.stopDate is null "); */
		StringBuffer hqlConditions = new StringBuffer("where pathways.validationCompletedDT is null "+
				" and pathways.validationCompletedBy is null "+
				" and (pathways.isRIE = FALSE or pathways.isRIE is null) "+
				" and referral.rTTClockImpact = TRUE" +
				" and (service.isRIE = FALSE or service.isRIE is null) " +
				" and refdetails.service.id is not null "+
				" and cc is not null "+
				" and cc.stopDate is null ");

		if (searchCriteria != null 
			&& searchCriteria.getStartDateIsNotNull() 
			&& Boolean.FALSE.equals(searchCriteria.getRttIncluded()))
		{
			hqlConditions.append("and (pathways.nextValidationDate is not null");
			validationDateAdded = true;
			
			hqlConditions.append(" and (pathways.nextValidationDate >= :fromDate ");
			markers.add("fromDate");
			DateTime fromDateTime = new DateTime( searchCriteria.getStartDate(), new Time(0, 0));
			values.add(fromDateTime.getJavaDate());
		}

		if (searchCriteria != null 
				&& searchCriteria.getEndDateIsNotNull() 
				&& Boolean.FALSE.equals(searchCriteria.getRttIncluded()))
		{
			if (Boolean.FALSE.equals(validationDateAdded))
			{
				hqlConditions.append("and pathways.nextValidationDate is not null");
				validationDateAdded = true;
			}
			
			hqlConditions.append(" and pathways.nextValidationDate <= :toDate)) ");
			markers.add("toDate");
			DateTime toDateTime = new DateTime( searchCriteria.getEndDate(), new Time(0, 0));
			values.add(toDateTime.getJavaDate());
		}
		
		if (searchCriteria != null 
				&&  Boolean.TRUE.equals(searchCriteria.getRttIncluded()))
		{
			hqlConditions.append(andStr);
			
			hqlConditions.append(" ("+
								"("+
								"    	pathways.nextValidationDate is not null" +
								"	and pathways.nextValidationDate >= :notValidatedStartDate" +
								"	and pathways.nextValidationDate <= :notValidatedEndDate" +
								"	and (pathways.isRIE = 0 or pathways.isRIE is null)" +
								")"+
								" or "+
								"	(	 pathways.nextValidationDate is null "+
								"	and  refdetails.end18WW  is not null" + //WDEV-22258
								"	and  refdetails.end18WW >= :startDate" + //WDEV-22258
								"	and refdetails.end18WW <= :endDate" +	//WDEV-22258								
								"	and (pathways.isRIE = 0 or pathways.isRIE is null)"+
								"   )"+
								") ");
			
			markers.add("notValidatedStartDate");
			DateTime notValidatedStartDate = new DateTime();
			values.add(notValidatedStartDate.addDays(-(searchCriteria.getNotValidatedNoOfWeeks() * 7)).getJavaDate());
			
			markers.add("notValidatedEndDate");
			values.add(new DateTime().getJavaDate());
			
			markers.add("startDate");
			values.add(new ims.framework.utils.Date().getDate());
			
			markers.add("endDate");
			ims.framework.utils.Date startDate = new ims.framework.utils.Date();
			values.add(startDate.addDay((searchCriteria.getNoOfWeeks() * 7)).getDate());
				
			rttValidationAdded = true;
		}


		if (serviceIds != null && serviceIds.length() > 0)
		{
			hqlConditions.append(serviceIds);
		}

		//Sorting 
		if (Boolean.TRUE.equals(validationDateAdded))
		{
			hqlConditions.append(" order by pathways.nextValidationDate desc");	
		}
		else if (Boolean.TRUE.equals(rttValidationAdded))
		{
			hqlConditions.append(" order by refdetails.end18WW desc");	
		}

		if ((Boolean.TRUE.equals(validationDateAdded)) || (Boolean.TRUE.equals(rttValidationAdded)))
			hqlConditions.append(", refdetails.service.serviceName asc");
		else if (! (Boolean.TRUE.equals(validationDateAdded)) && ! (Boolean.TRUE.equals(rttValidationAdded)))
		{
			hqlConditions.append(" order by refdetails.service.serviceName asc");
		}


		
		hql = hql.append(hqlConditions.toString());
		List<?> hqlList = getDomainFactory().find(hql.toString(), markers, values);

		// Assemble PatientPathwaysAwaitingValidationWorklistVo from Pathway and Service (hqlList rray elements 0 and 1)
		PatientPathwaysAwaitingValidationWorklistVoCollection returnVoCollection = new PatientPathwaysAwaitingValidationWorklistVoCollection();
		for (Object object : hqlList)
		{
			Object[] array = (Object[])object;

			PatientPathwayJourney patientPathJourney = (PatientPathwayJourney)array[0];
			PatientPathwaysAwaitingValidationWorklistVo workListVo = PatientPathwaysAwaitingValidationWorklistVoAssembler.create(patientPathJourney);

			if (workListVo != null)
			{	
				Service service = (Service)array[1];
				ServiceShortVo serviceItem = ServiceShortVoAssembler.create(service);
				workListVo.setService(serviceItem);

				Hcp hcp = (Hcp)array[2];
				HcpLiteVo respHCP = HcpLiteVoAssembler.create(hcp);
				workListVo.setResponsibleConsultant(respHCP);
			}

			returnVoCollection.add(workListVo);

		} 
		
		return returnVoCollection;
		
		// End of WDEV-21431 changes
		
	}


	//WDEV-21155
	@Override
	public void savePatientPathwayJourney(PatientPathwaysAwaitingValidationWorklistVo patientPathwayJourneyVo) throws DomainInterfaceException, StaleObjectException
	{
		if(patientPathwayJourneyVo == null)
			throw new CodingRuntimeException("Invalid PatientPathwaysAwaitingValidationWorklistVo");

		DomainFactory factory = getDomainFactory();
		
		PatientPathwayJourney domPatientPathwayJourney = PatientPathwaysAwaitingValidationWorklistVoAssembler.extractPatientPathwayJourney(factory, patientPathwayJourneyVo);
		
		domPatientPathwayJourney.setLastValidationDate(domPatientPathwayJourney.getNextValidationDate());
		domPatientPathwayJourney.setNextValidationDate(null);
		
		factory.save(domPatientPathwayJourney);
	}

	//WDEV-21389
	@Override
	public CatsReferralListVo getCatsReferral(PatientPathwayJourneyRefVo journey)
	{
		if (journey == null)
			return null;

		DomainFactory factory = getDomainFactory();

		String hql = "select cr from CatsReferral as cr left join cr.journey as joy where  (cr.journey.id = " + journey.getID_PatientPathwayJourney() +")";
		
		CatsReferral referralList = (CatsReferral) factory.findFirst(hql);

		if (referralList != null)
			return CatsReferralListVoAssembler.create((CatsReferral) referralList);

		return null;
	}

	//WDEV-21389
	@Override
	public CareContextShortVo getCareContextShort(CareContextRefVo voCareContextRef)
	{
		if (voCareContextRef == null)
			throw new RuntimeException("Cannot get CareContextShortVo for null CareContextRefVo");

		CareContext doCareContext = (CareContext) getDomainFactory().getDomainObject(CareContext.class, voCareContextRef.getID_CareContext());
		return CareContextShortVoAssembler.create(doCareContext);
	}
	
	//WDEV-21431
	public ServiceShortVoCollection getReferralServices(String serviceName)
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hqlJoins = new StringBuffer("select s from ReferralService rs left join rs.referralServices as s left join s.specialty as ss ");
		StringBuffer hql = new StringBuffer(" ");
	
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		String andStr = " ";
		
		if(serviceName != null)
		{
			hql.append(" s.upperName like :ServiceName ");
			markers.add("ServiceName");
			values.add(serviceName.toUpperCase() + "%");
			andStr = " and ";
		}
		
		if (markers.size() > 0)
			hql.insert(0, " where ");
		
		hql.append( " order by s.upperName asc" );
		
		List<?> list = factory.find(hqlJoins.append(hql.toString()).toString(), markers, values);
		
		return ServiceShortVoAssembler.createServiceShortVoCollectionFromService(list);

	}

	//WDEV-21431
	public ServiceShortVoCollection listServicesForLoggedHCP(HcpRefVo hcp)
	{
		if (hcp == null || hcp.getID_Hcp() == null)
			return null;
		
		ArrayList<String> paramName= new ArrayList<String>();
		ArrayList<Object> paramValue = new ArrayList<Object>();
		
		String query = "select s from Hcp as h left join h.serviceFunction as hsf left join hsf.service as s, ReferralService as rs left join rs.referralServices as rss where hsf.isActive = :isActive and s.id = rss.id and h.id = :HcpId order by s.upperName asc";
		
		paramName.add("HcpId");		
		paramValue.add(hcp.getID_Hcp());

		paramName.add("isActive");		
		paramValue.add(Boolean.TRUE);

		List serviceList = getDomainFactory().find(query, paramName, paramValue);
		
		return ServiceShortVoAssembler.createServiceShortVoCollectionFromService(serviceList);

	}
	
	private String getBaseSelectQuery(Boolean includeICPColumn, Boolean includeELEColumn)
	{
		String name = ims.configuration.ConfigFlag.UI.DISPLAY_PATID_TYPE.getValue();
		ims.core.vo.lookups.PatIdType displayPatIDType = ims.core.vo.lookups.PatIdType.getNegativeInstance(name);

		/* TODO MSSQL case - String hqlSB = "select new ims.RefMan.helper.CatsReferralManualClass( catsref.id, title1.text, pat1.name.surname, pat1.name.forename, " +
		" (select max(p21_1.value) from Patient as p11_1 left join p11_1.identifiers as p21_1 where (p21_1.type = -9 and p11_1.id = pat1.id)) as ANY_NHS, " +
		" (select max(p211_1.value) from Patient as p111_1 left join p111_1.identifiers as p211_1 where (p211_1.type = -9 and p211_1.verified = 1 and p111_1.id = pat1.id)) as VERIFIED_NHS," +
		" (select max(p21_1.value) from Patient as p11_1 left join p11_1.identifiers as p21_1 where (p21_1.type = " + displayPatIDType.getID() + " and p11_1.id = pat1.id)) , " +
		" pat1.dod, "; */
		String hqlSB = "select new ims.RefMan.helper.CatsReferralManualClass( catsref.id, title1.text, pat1.name.surname, pat1.name.forename, " +
		" (select max(p21_1.value) from Patient as p11_1 left join p11_1.identifiers as p21_1 where (p21_1.type = -9 and p11_1.id = pat1.id)) as ANY_NHS, " +
		" (select max(p211_1.value) from Patient as p111_1 left join p111_1.identifiers as p211_1 where (p211_1.type = -9 and p211_1.verified = TRUE and p111_1.id = pat1.id)) as VERIFIED_NHS," +
		" (select max(p21_1.value) from Patient as p11_1 left join p11_1.identifiers as p21_1 where (p21_1.type = " + displayPatIDType.getID() + " and p11_1.id = pat1.id)) , " +
		" pat1.dod, ";

		if (includeICPColumn)
			hqlSB+="(select max(icp.careContext.id) from PatientICP as icp where icp.careContext.id = catsref.careContext.id),";
		else
			hqlSB+= "catsref.id, ";
		
		if (includeELEColumn)
			hqlSB+="(select max(ele.id) from PatientElectiveList as ele where ele.referral.id = catsref.id),";
		else
			hqlSB+= "catsref.id, ";
			
		hqlSB+="refDetails.dateOfReferral, catsref.isCAB, loc1.name, service1.serviceName, catsref.isFlaggedForReview, refDetails.end18WW, catsref.isCurrentlyAllocated, " +
		"catsref.hasInvestigations, addinv.id, refstat1.id, refstat1.text, catsref.hasAppointments, " +
		"appt1.apptStatus.id, appt1.appointmentDate, appt1.apptStartTime, pat1.associatedPatient.id , refDetails.dateReferralReceived, catsref.hasDocuments, catsref.hasReferralLetter, refDetails.endDateKPI, ur.id, ur.text, triageOutcomeStatus.id, triageOutcomeStatus.text, (select max(triagePendingDiagnosticResult.id) from TriageOutcome as triageOutcome left join triageOutcome.triagePendingDiagnosticResult as triagePendingDiagnosticResult where (triageOutcome.catsReferral.id= catsref.id)), catsref.rTTClockImpact ) ";	//wdev-19673 //WDEV-20880
		return hqlSB;
	}
	
	private String getBaseJoinQuery()
	{
		return 	"left join catsref.referralDetails as refDetails left join refDetails.service as service1 ";
	}
	
	
	private String getServicesIds(CATSReferralFilterVo criteria)
	{
		if(criteria == null)
			return null;
		
		if(criteria.getService() == null && criteria.getServices() == null)
			return null;
		
		StringBuffer ids = new StringBuffer();
		
		if(criteria.getService() != null)
		{
			ids.append(criteria.getService().getID_Service());
		}
		else if(criteria.getServices() != null)
		{
			for( ServiceShortVo cfg : criteria.getServices())
			{
				if(cfg == null)
					continue;
				
				if(ids.length() > 0)
					ids.append(",");
				
				ids.append(cfg.getID_Service());
			}
		}
		
		return ids.toString();
	}

	
	//WDEV-21431
	private CatsReferralListManualAssemblyVoCollection assembleRecords(List<?> refList) 
	{
		CatsReferralListManualAssemblyVo voItem = null;
		CatsReferralListManualAssemblyVoCollection voColl = new CatsReferralListManualAssemblyVoCollection();
		for (int i = 0 ; i < refList.size(); i ++)
		{
//			CatsReferralManualClass doCats = (CatsReferralManualClass)refList.get(i);
			CatsReferral doCats = (CatsReferral)refList.get(i);
			voItem = new CatsReferralListManualAssemblyVo();
	
			voItem.setCatsReferralId(doCats.getId()); // getCatsReferralId());
//			voItem.setPatientName(doCats.getPatientName());
//			voItem.setVerifiedNHSNumber(doCats.getPatientnhsnum());
//			voItem.setAnyNHSNumber(doCats.getAnynhsnum());
//			voItem.setDisplayPatID(doCats.getDysplayPatID()); //WDEV-19621
//			voItem.setPatientDOD(doCats.getPatientDOD() != null ? new ims.framework.utils.Date(doCats.getPatientDOD()) : null);
//			voItem.setLinkedICPID(doCats.getLinkedICPID() != null ? Boolean.TRUE : null);
//			voItem.setLinkedELEID(doCats.getLinkedELEID() != null ? Boolean.TRUE : null);
//			voItem.setIsCAB(doCats.getisCAB());
//			voItem.setReferralLocationName(doCats.getReferralLocationName());
			voItem.setServiceName(doCats.getReferralDetails().getService().getServiceName()); //getServiceName());
//			voItem.setIsFlaggedForReview(doCats.getisFlaggedForReview());
//			voItem.setEnd18WW(doCats.getEnd18WW() != null ? new ims.framework.utils.Date(doCats.getEnd18WW()) : null);
//			voItem.setIsCurrentlyAllocated(doCats.getisCurrentlyAllocated());
//			voItem.setHasInvestigations(doCats.getHasInvestigations());
//			voItem.setCatsCurrentStatus(doCats.getCatsCurrentStatusId() != null ? new LookupInstVo(doCats.getCatsCurrentStatusId(), doCats.getCatsCurrentStatusText(), Boolean.TRUE) : null);
//			voItem.setAdditionalInvStatus(doCats.getAdditionalInvStatusID() != null ? new LookupInstVo(doCats.getAdditionalInvStatusID(), "", Boolean.TRUE) : null);
//			voItem.setHasApointments(doCats.getHasApointments());
//			voItem.setConsultationApptStatus(doCats.getConsAppointmentStatusID() != null ? new LookupInstVo(doCats.getConsAppointmentStatusID(), "", Boolean.TRUE) : null);
//			voItem.setConsAppointmentDate(doCats.getConsAppointmentDate() != null ? new ims.framework.utils.Date(doCats.getConsAppointmentDate()) : null);
//			voItem.setConsultationApptStartTime(doCats.getConsAppointmentStartTime() != null ? doCats.getConsAppointmentStartTime() : null);
//			voItem.setAssociatedPatientId(doCats.getAssociatedPatientId());
//			voItem.setDateReceived(doCats.getDateRecieved() != null ? new ims.framework.utils.Date(doCats.getDateRecieved()) : null);
//			voItem.setReferralDate(doCats.getReferralDate()!= null ? new ims.framework.utils.Date(doCats.getReferralDate()) : null);
//			voItem.setPatSurname(doCats.getPatientSurname());
//			voItem.setPatForename(doCats.getPatientForename());
//			voItem.setPatTitle(doCats.getPatientTitle());
//			voItem.setEndDateKPI(doCats.getEndDateKPI() != null ? new ims.framework.utils.Date(doCats.getEndDateKPI()) : null);
//			voItem.setReferralUrgency(doCats.getReferralUrgencyID() != null ? new LookupInstVo(doCats.getReferralUrgencyID(), doCats.getReferralUrgencyText(), Boolean.TRUE) : null);
//			voItem.setTriageOutcomeStatus(doCats.getTriageOutcomeStatusId() != null ? new LookupInstVo(doCats.getTriageOutcomeStatusId(), doCats.getTriageOutcomeStatusString(), Boolean.TRUE) : null);
//			voItem.setHasTriagePendingDiagnosticResult(doCats.getHasTriagePendingDiagnosticResult()!=null ? Boolean.TRUE: Boolean.FALSE); //WDEV-20880
//			
//			if (doCats.getEnd18WW() != null)
//			{
//				StringBuffer sb = new StringBuffer();
//				sb.append(voItem.getEnd18WW().getYear());
//				
//				if (voItem.getEnd18WW().getMonth() > 9)
//					sb.append(voItem.getEnd18WW().getMonth());
//				else
//				{
//					sb.append("0");
//					sb.append(voItem.getEnd18WW().getMonth());
//				}
//					
//				if (voItem.getEnd18WW().getDay() > 9)
//					sb.append(voItem.getEnd18WW().getDay());
//				else
//				{
//					sb.append("0");
//					sb.append(voItem.getEnd18WW().getDay());
//				}
//				voItem.setEnd18wwJulianDate(sb.toString());
//			}
//			
//			if( voItem.getConsultationApptStatusIsNotNull()	&& voItem.getConsultationApptStatus().equals(Status_Reason.BOOKED))
//			{
//				if (voItem.getConsAppointmentDateIsNotNull())
//				{
//					long lval = Date.daysBetween(new Date(voItem.getConsAppointmentDate()), new Date());
//
//					voItem.setDaysLeft(-(int)lval);
//				}
//			}
//			
//			voItem.setRTTClockImpact(doCats.getRTTClockImpact());

			voColl.add(voItem);
		}
		
		return voColl;	
	}

//	@Override
//	public CatsReferralListManualAssemblyVoCollection listCATSReferrals(CATSReferralFilterVo voCATSFilter)
//	{
//		// TODO Auto-generated method stub
//		return null;
//	}



}
